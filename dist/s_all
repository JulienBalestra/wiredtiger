#! /bin/sh

# Run standard scripts.
t=__wt.$$
t_pfx=__s_all_tmp
trap 'rm -f $t *.pyc __tmp __wt.* __s_all_tmp*' 0 1 2 3 13 15
FAIL_HEADER="####################### ERROR ############################"

# We require python which may not be installed.
type python > /dev/null 2>&1 || {
	echo 's_all: python not found'
	exit 1
}

run()
{
	error_prefix="s_all run of: $1 resulted in:"
	$1 > $t

	if `grep 'skipped' $t > /dev/null 2>&1`; then
		echo "$FAIL_HEADER"
		printf "$error_prefix"
	        printf "	" && cat $t
	elif `test -s $t`; then
		echo "$FAIL_HEADER"
		printf "$error_prefix"
		echo
		sed -e 's/^/	/' $t
	fi
	rm -f $t
	return 0
}

echo 'dist/s_all run started...'

force=
reconf=0
while :
	do case "$1" in
	-A)	# Reconfigure the library build.
		reconf=1
		shift;;
	-f)	# Force versions to be updated
		force="-f"
		shift;;
	*)
		break;;
	esac
done

run "sh ./s_version $force" "Updating files that include the package version"

test "$reconf" -eq 0 || {
	(cd ../build_posix &&
	run "sh ./reconf" "Rebuilding GNU tools library support")
}

# Non parallelizable scripts The following scripts either modify files or
# already parallelize internally.
run "sh ./s_readme $force"
run "python api_config.py"
run "python api_err.py"
run "python flags.py"
run "python log.py"
run "python stat.py"
run "python java_doc.py"
run "sh ./s_prototypes"
run "sh ./s_typedef -b"
run "sh ./s_copyright"
run "sh ./s_style"

read -d '' COMMANDS <<EOM
'sh ./s_tags > ${t_pfx}tags'
'sh ./s_define > ${t_pfx}s_define'
'sh ./s_typedef -c > ${t_pfx}s_typedef_c'
'sh ./s_funcs > ${t_pfx}s_funcs'
'sh ./s_export > ${t_pfx}s_export'
'sh ./s_getopt > ${t_pfx}s_getopt'
'sh ./s_label > ${t_pfx}s_label'
'sh ./s_lang > ${t_pfx}s_lang'
'sh ./s_longlines > ${t_pfx}s_longlines'
'sh ./s_stat > ${t_pfx}_stat'
'sh ./s_string > ${t_pfx}s_string'
'python style.py > ${t_pfx}py_style'
'sh ./s_python > ${t_pfx}s_python'
'sh ./s_whitespace > ${t_pfx}s_whitespace'
'sh ./s_win > ${t_pfx}s_win'
'sh ./s_docs > ${t_pfx}s_docs'
EOM

echo "$COMMANDS" | xargs -P 20 -n 1 -I{} /bin/sh -c {}

for f in `find . -name ${t_pfx}\*`; do
	if ! `test -s $f`; then
		continue
	fi
	LOCAL_NAME=`basename $f`
	FAILED_CMD=`echo "$COMMANDS" | grep $LOCAL_NAME | cut -d '>' -f 1`
	echo "$FAIL_HEADER"
	echo "s_all run failed: $FAILED_CMD produced"
	cat $f
done

echo 'dist/s_all run finished'
